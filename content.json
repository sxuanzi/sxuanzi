{"meta":{"title":"小可爱的博客","subtitle":null,"description":null,"author":"文煊","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"java内存分配","slug":"java内存分配","date":"2018-11-21T02:59:36.000Z","updated":"2018-11-21T14:18:40.769Z","comments":true,"path":"2018/11/21/java内存分配/","link":"","permalink":"http://yoursite.com/2018/11/21/java内存分配/","excerpt":"","text":"栈区（stack）：由编译器自动分配释放，存放函数的参栈区（stack），由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，链表的数据空间必须采用堆存储分配策略。 全局区（静态区）（static）：全局变量和静态变量的存储是放在这一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。 文字常量区：常量字符文字常量区：常量字符串就是放在这里的，程序结束后由系统释放。 程序代码区：存放函数体的二进制代码。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[]},{"title":"数据结构概述","slug":"郝斌_数据结构概述","date":"2018-11-21T02:59:36.000Z","updated":"2018-11-21T14:18:59.897Z","comments":true,"path":"2018/11/21/郝斌_数据结构概述/","link":"","permalink":"http://yoursite.com/2018/11/21/郝斌_数据结构概述/","excerpt":"","text":"一、数据结构概述1.什么是数据结构？ 我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器（内存）中，以及在此基础上为实现某个功能（比如查找某个元素，删除某个元素，对所有元素进行排序）而执行的相应操作，这个相应的操作也叫算法 数据结构 = 个体的存储 + 个体的关系存储； 算法 = 对存储数据的操作； 2.衡量算法的标准 1）时间复杂度：大概程序执行的次数，而非执行的时间 2）空间复杂度： 算法执行过程中大概所占用的最大内存 3）难易程度 4）健壮性 3.预备知识——指针 指针的重要性：指针是C语言的灵魂 地址：地址是内存单元的编号，从0开始的非负整数，范围：0-FFFFFF【0-4 G-1】 CPU==========-地址线，控制线，数据线 ===========内存 指针：指针就是地址，地址就是指针。指针变量是存放内存单元地址的变量。指针的本质是一个操作受限的非负整数。 分类 1.基本类型指针 Int *p; //*p要保存一个内存地址（p是个变量名字，int *表示该p变量只能存储int类型变量的地址） Int i = 10; Int j; j=*p; char ch = &apos;A&apos;; // p =&amp;ch;//error // p =10；//error p = &amp;i;//正确 *p =i;//error 等价于i=i //上行代码表示p指向i，则p就是i j = *p; //等价于j=i Printf(“%d\\n”,j) 函数void f(int *p){ //不是定义一个名字*p的形参，而是定义了一个形参，该形参的名字叫做p，它的类型是int *(p指向了i,p就是i) *p = 100; } main{ int i =9; f(&amp;i); } 如何通过被调函数修改主调函数中普通变量的值-实参为相关变量的地址 -形参为以该变量类型为类型的指针变量 -在被调函数中通过 *形参变量名 的方式就可以修改主调函数的值 指针和数组Show_Array(int *p, int len){ int i =0; for //p[0] = -1; //p[0] == *p //p[2] = -1; //p[2] == *(p+2) == *(a+2) ==a[2] } main(void){ int a[5] = {1,2,3,4,5,}; // Show_Array(a,5) //数组名表示的就是第一个元素的地址,a==&amp;a[0] } 数组名：一维数组名是个指针常量， 它存放的是一维数组第一个元素的地址 它的值不能被变 一维数组名指向的就数组的第一个元素 下标和指针的关系a[i] &lt;&lt;==&gt;&gt; *(a+i) 指针变量所占的字节关系double * p; doubl x = 66.6; p = &amp;x;//x占8个字节 1个字节是8(#`O′)，1个字节一个地址,p存放的是x的首地址 //不论指针变量指向的地址占多少个字节，指针变量都统一占4个字节 如何以过函数修改实参的值main(void){ int i=0; int * p = &amp;i; f(&amp;p); } f(int **p){ *p=(int *)OxFFFFFF; } 结构体： 1).为什么会出现结构体 – 为了表示一些复杂的数据，而基本的数据类型变量无法满足要求 2）什么叫结构体 – 结构体是用户根据实际需要自己定义的复合数据类型 3）结构体的定义方法 Strcut 结构体名{ 内容：例如：int name }; //分号不能省 //例如：该下列代码：定义了一个 strucut Student类型，该类型有三个成员 strcut Student{ int sid; char name[200]; int age; } main(void){ //第一个赋值方法和定义 struct Student st = {1000.&quot;zhangsan&quot;,20}; st.sid = 99; strcopy(st.name,&quot;list&quot;); st.age = 33; } 第二种赋值方法 main(void){ struct Student st = {100,&quot;zhangsan&quot;,20}; struct Student * pst = &amp;st; pst-&gt;sid = 99； //pst-&gt;等价于(*pst).sid 而(*pst).sid等价于st.sid，使用pst-&gt;sid 等价于st.sid // pst所指向的结构体变量中的sid这个成员 } 注意事项: /**1)结构体变量不能加减乘除，但可以相互赋值。 *2)普通结构体变量和结构体指针变量作为函数传参问题 */ main(void){ struct Student st; //静态变量 f(&amp;st); g(&amp;st); } void g(struct Student * st){ printf(*(st).sid); printf(st-&gt;name); } void f(struct Student * pst){ (*pst).sid = 99; strcpy(pst-&gt;name,&quot;zhangsan&quot;); pst-&gt;age = 22; } C语言字符串赋值要使用： strcpy(st.name,”list”); 动态内存的分配和释放main(void){ int a[5] = {4,2,4,5,6}; int len = 5; printf(&quot;请输入你需要分配的数组的长度：len=&quot;); scanf(&quot;%d&quot;, len); //把你请求需要的字节的地址赋给pArr malloc只返回第一个字节的地址 sizeof(int)表示返回int类型所占字节 //下述代码表示：总共分配了20个字节，pArr指向的前四个字节 pArr+1指向的后四个字节 和a[5]意思相同，a[5] //静态变量，下述代码表示动态变量 int * pArr = (int *)malloc(sizeof(int) * len); *pArr = 4; //等价于 a[0] =4; pArr[1] = 10; //等价于a[1] = 10; //下述代码：把pArr所代表的动态分配的20个字节的内存释放 free(pArr); return 0; } 跨函数使用内存讲解通过动态分配内存，可以使得跨函数使用内存","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]},{"title":"数组","slug":"数组","date":"2018-11-21T02:59:36.000Z","updated":"2018-11-21T14:18:46.424Z","comments":true,"path":"2018/11/21/数组/","link":"","permalink":"http://yoursite.com/2018/11/21/数组/","excerpt":"","text":"什么是数组？数组是一种线性表数据结构，他用一组连续的内存空间，来存储一组具有相同类型的数组。 线性表:就是数据排成一条线的结构 随机访问？因为数组是连续内存空间和一组相同类型，可以使的数据具有随机访问性。 数组如何实现随机访问性？计算机会给每个内存分配一个地址，计算机通过地址来访问内存的数据，当计算机随机访问数组中的某个元素时:可以通过寻址公式来查找数据:a[i]_address = base_address + i * data_type_size 低效的“删除”和“插入”插入 在数组中插入一个值，假设数组长度为n，我们要在末尾插入，时间复杂度则为O(1)，如果在k的位置插入则为O(n)，其实我们可以在k要删除的位置元素，我们可以将k的数据搬到元素的末尾，将新元素插入到k位置。 删除 每次要删除的时候，我们可以记录下要删除元素的数据，当数组没有存储空间的时候，一次性触发删除。 为什么数组是从0开始的？数组的存储的内存模型来看，“下标”简称偏移量，如果a表示数组的首地址，a[0]就是偏移量为0的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，运用的就是上面那个公式。如果数组从1开始，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]},{"title":"线性结构","slug":"郝斌_线性结构","date":"2018-11-21T02:59:36.000Z","updated":"2018-11-21T11:39:58.468Z","comments":true,"path":"2018/11/21/郝斌_线性结构/","link":"","permalink":"http://yoursite.com/2018/11/21/郝斌_线性结构/","excerpt":"","text":"线性结构连续存储[数组]1.什么叫做数组 元素类型相同，大小相同 连续存储数组的算法代码：Arr.c typedef的用法typedef int zhangsan;//为int再重新多取一个名字，zhangsan等价于int typedef struct Student{ int sid; char name[100]; char sex; }st; int main(void){ int i =10; //等价于zhangsan i =10; //struct Student st; //等价于st s; //struct Student * ps = &amp;st; //等价于st * sp; return 0; } typedef struct Student{ int sid; char name[100]; char sex; }* pst; //pst 等价于struct Student * /* struct Student{ int sid; char name[100]; char sex; }* 整体为一个类型 */ typedef struct Student{ int sid; char name[100]; char sex; }* PST，ST; //等价于st代表了struct Student ,pst 代表了struct Student * 一般别名都用大写 int main(void){ return 0; } 离散存储[链表]定义： n个节点离散分配 彼此通过指针相连 每个节点只有一个前驱结点,每个节点只有一个后续节 首节点每页前驱结点，尾节点每页后续节点 专业术语： 首节点：第一个有效节点 尾节点：最后一个有效节点 头节点：不存放有效数组，头节点指向首节点（第一个有效节点之前的那个节点），主要是为了方便对链表的操作，头节点的数据类型和首节点的类型是一样的 头指针：指向头节点的指针变量 尾指针：指向尾节点的指针变量 如果希望通过一个函数来对链表进行处理，我们至少需要接受链表的那些参数：只需要一个参数：头指针（因为我们通过头指针可以推算出链表的其他所有的信息） 每一个链表节点的数据类型该如何表示的问题//一个结构体变量的成员指向它本身（它本身的数据类型是一样的另外一个变量） typedef struct Node{ int data;//数据域 struct Node * pNext; //指针域 } 链表分类：单链表 双链表：每一个节点有两个指针域 循环链表：能通过任何一个节点找到其他所有的节点 非循环链表： 算法：伪算法： 算法： 狭义的算法是与数据的存储方式密切相关广义的算法是与数据的存储方式无关 泛型：利用某种技术达到的效果就是：不同的存数方式，执行的操作是一样的 遍历 查找 清空 销毁 求长度 排序 删除节点 如何去学习算法：1.流程2.每个语句的功能3.试数先看着敲一遍代码然后自己敲一遍代码 复习数据结构： 狭义： 数据结构是专门研究数据存储的问题 数据的存储包含两方面：个体的存储+个体关系的存储 广义： 数据结构即包含数据的存储也包含数据的操作 算法是对存储数据的操作 算法： 狭义 算法是与数据的存储方式密切相关 广义 算法是与数据的存储方式无关 这就是泛型思想 数据的存储有几种： 线性 连续存储【数组】 优点：存取速度很快 缺点：插入删除很慢，空间通常是有限制的，需要大块连续的内存块 离散存储【链表】 优点：空间没有限制，插入删除元素很快 缺点：存取速度很快 线性结构的应用 --栈 线性结构的应用 --队列 非线性 线性结构的两种常见应用之一 栈 【静态内存是在栈中分配的，动态内存是在堆里面分配的】 栈和堆表示的是分配数据的一种方式栈：压栈出栈的方式 堆：堆排序的方式 定义：一种可以实现“现今后出”的存储结构 栈类似于箱子 分类：静态栈：(以数组为它的基本内核)动态栈：（以链表为它的基本内核） 算法出栈压栈 应用栈程序演示 栈：top和button 栈的应用函数调用，中断，表达式求值，内存分配，缓冲处理，迷宫 线性结构的两种常见应用之二 队列专题：递归","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]},{"title":"递归","slug":"郝斌_递归","date":"2018-11-21T02:59:36.000Z","updated":"2018-11-21T14:18:36.359Z","comments":true,"path":"2018/11/21/郝斌_递归/","link":"","permalink":"http://yoursite.com/2018/11/21/郝斌_递归/","excerpt":"递归","text":"递归 递归的概念一个函数自己直接或者间接调用自己 函数的调用 当在一个函数的运行期间调用另一个函数时，在运行被调函数之前，系统需要完成三件事情： 1.将所有的实际参数，返回地址等信息传递给被调函数保存 2.为被调函数的局部变量（也包括形参）分配空间 3.将控制转移到被调函数的入口 从被调函数返回主调函数之前，系统也要完成三件事情： 1.保存被调函数的返回结果 2.释放被调函数所占的存储空间 3.依照被调函数保存的返回地址将控制转移到调用函数 当有多个函数相互调用时，按照“后调用先返回”的原则，上述函数之间信息传递和控制转移必须借助“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就在栈顶分配一个存储区，进行压栈操作，每当一个函数退出时，就释放它的存储区，就行出栈操作，当前运行的函数永远都在栈顶位置 A函数调用A函数和A函数调用B函数在计算机看来是没有任何区别的，只不过用我们日常的思维方式理解比较怪异 递归必须满足的三个条件 递归必须得有一个明确的中止条件 该函数所处理的数据规模必须在递减 这个转化必须是可解的 循环和递归的递归： - 易于理解 - 速度慢 - 存储空间大 循环 - 不易理解 - 速度快 - 存储空间小 汉诺塔印象笔记 走迷宫比如有东南西北四个方向，将每一个方向进行压栈处理，当一个方向走完就进行出栈处理。 递归的应用树和森林就是以递归的方式定义的 数和图很多算法都是以递归来实现的 很多数学公式就是以递归的方式定义的","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]},{"title":"队列","slug":"郝斌_队列","date":"2018-11-21T02:59:36.000Z","updated":"2018-11-21T14:18:32.364Z","comments":true,"path":"2018/11/21/郝斌_队列/","link":"","permalink":"http://yoursite.com/2018/11/21/郝斌_队列/","excerpt":"队列","text":"队列 队列定义：一种可以实现“先进先出”的存储结构队列分类 链式队列 使用链表实现的 使用front（队头）和rear（队尾）来表示 对队列的操作为出队和入队 静态队列 使用数组实现的 静态队列通常都必须是循环队列 循环队列的讲解1. 静态队列为什么必须是循环队列 减少对内存的浪费 因为队列是从头部开始删除的，如果删除一个元素，则对头就往上移一个那被删除的空间就不可以再使用了 如果我们使用传统的数组来实现静态队列，不管是出队还是入队数组则是一直再增 2. 循环队列需要几个参数来确定及含义的讲解 - 需要2个参数来确定 - front rear 3.循环队列各个参数的含义 - 2个参数不同场合有不同的含义（建议初学者先记住，然后慢慢体会） - 1）队列初始化 - font和rear的值都是零 - 2）队列非空 - font代表的是队列的第一个元素 - rear代表的是队列的最后一个有效元素 - 3）队列空 - font和rear的值相等，但不一定是零 4. 循环队列入队伪算法讲解 两步完成： 将值存入r所代表的位置 错误的写法r= r+1; 正确的写法是： r = (r+1) %数组的长度 5. 循环队列出队伪算法讲解 一步完成： f = （f+1）%数组的长度 6. 如何判断循环队列是否为空 如果front与rear的值相等， 则该队列一定为空 7. 如何判断循环队列是否已满 两种方式： 1.多增加一个标志参数 2.少使用一个元素（常用）：如果r和f的值紧挨着，则队列已满 算法： if((r+1)%数组长度==f) 已满 else 不满 队列的算法出队 xunhuan.c 入队 队列的具体应用所以和时间的有关的操作都有队列的影子","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]},{"title":"链表","slug":"链表","date":"2018-11-21T02:59:36.000Z","updated":"2018-11-21T14:18:54.445Z","comments":true,"path":"2018/11/21/链表/","link":"","permalink":"http://yoursite.com/2018/11/21/链表/","excerpt":"","text":"什么是链表？通过指针将离散的内存空间连接一起。 什么叫节点？将内存快称为节点 什么叫做后续指针next？每个链表的结点除了存储数据，还需要存储链上指向下一个结点的地址。 记录下结点地址的指针叫做后续指针next 链表有两个特殊的节点 一个是叫做头结点 一个叫做尾结点 什么叫做头结点？头结点用来记录链表的基地址 什么叫做尾结点？指针不是指向下一个结点地址，而是指向一个NULL地址，表示链表的最后一个结点。 链表的插入和删除结点O(1) 链表的随机访问性度O(n) 循环链表就是将尾结点的指针指向链表的头结点 双向链表每个结点有一个前驱指针prev指向前面的结点,还有一个后续指针next指向后面的结点好处:双向链表可以支持在O(1)时间复杂度的情况下找到前驱结点 思考:通过学习，我们以后知道一个很重要的知识点:用空间换时间的设计思想，当内存充足的时候，如果我们追求代码执行的速度，空间复杂度比较高，时间复杂度比较低的算法和数据结构。如果内存比较紧缺，比如代码是执行在手机或者单片机上，这个时候就反过来用时间换空间的设计思想。 缓存就是利用了空间换时间的设计思想。 链表VS数组数组内存大小固定，不能扩容(如果要扩容就需要申请一个更大的数组，如何将原数组copy到新的数组中。)，随机访问数组高效，插入删除低效链表:支持动态扩容，内存不限限制，因为链表每个结点都需要存下一次结点的指针，消耗内存翻倍，对链表的频繁删除和插入导致内存碎片。随机访问链表O(n)，插入删除O(1)","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]}]}